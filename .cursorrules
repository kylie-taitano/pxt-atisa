When reading .svg files, always treat them as text/XML files, never as image files. SVG files should be read using text-based tools like read_file, not as images.

## MakeCode/PXT Development Rules

### Pin Configuration
1. **Never create pin aliases that share the same physical pin (DAL value) unless you fully understand the use case**
   - Example: Don't define both `PIN_D9 = DAL.PA12` and `PIN_MISO = DAL.PA12` without verifying they won't conflict
   - The parts system gets confused when multiple pin names map to the same hardware pin
   - Test with simple code (e.g., `light.createStrip(pins.DX, 5)`) before assuming aliasing works

2. **When you see errors like "Cannot read properties of undefined (reading 'MOSI')":**
   - First check if the missing property (MOSI) should actually be defined for this specific board
   - Don't remove unrelated configurations (like i2cPins) to fix SPI errors
   - The error is telling you what's missing, not what to remove
   - Verify the board actually uses SPI before adding SPI pin definitions

3. **Board configuration files must be internally consistent:**
   - Every pin in `spiPins` and `i2cPins` (board.json) must have a corresponding `PIN_X` definition in config.ts
   - Every pin in `gpioPinMap` must map to an actual hardware pin, not LED labels (e.g., NEOPIXEL_0 is not a GPIO pin)
   - Empty `spiPins: {}` is valid and means "no SPI exposed to users"

4. **When copying configurations from reference boards:**
   - Understand WHY the reference board has those settings
   - Don't blindly copy pin mappings - physical boards route pins differently
   - Verify the target board actually uses the same pins for the same purposes
   - Check if pins are already used for other purposes before aliasing them

### Debugging Approach
5. **When something doesn't work, use isolation testing:**
   - Test in isolation (empty project, single pin, simple code)
   - Compare with known working configuration (vanilla fork, working board)
   - Use controlled experiments (test A0, then D7, then D9) to isolate which specific component causes issues
   - Don't jump to solutions - gather data first through systematic testing

6. **Missing `.show()` calls are LED Programming 101:**
   - Always check if `show()` is being called when LEDs don't light up on hardware
   - This should be the FIRST thing to check, not the last
   - NeoPixels won't update until show() is called

### Configuration Changes
7. **Before modifying board configuration:**
   - Ask: "Does this board actually expose this feature to students?"
   - Don't add SPI/I2C/Serial definitions just because other boards have them
   - Check the `features` array in pxt.json to understand what's actually needed
   - Verify student curriculum requirements before adding hardware features

8. **When errors reference "parts" or "PinInstantiationIdx":**
   - This is the parts/simulation system trying to figure out hardware usage at compile time
   - Check for pin definition conflicts (multiple names mapping to same DAL pin)
   - Check for missing pin mappings in gpioPinMap
   - Test with different pins to isolate which pins cause the error
   - Empty projects should compile without errors - if they do, the issue is in board config, not user code

### Architecture & Design Patterns
9. **Before creating custom abstractions, check how similar boards solve it:**
   - Search for boards with similar hardware (e.g., "onboard neopixels", "dual strips")
   - Read their implementation in `libs/[board-name]/`
   - Prefer extending existing patterns over inventing new ones
   - If creating custom namespace: ask "Why isn't the standard namespace sufficient?"

10. **When "parts" errors persist across multiple attempted fixes:**
   - STOP after 2-3 attempts with different pins/configurations
   - The issue is likely architectural, not configurational
   - "parts no pin found" = compile-time analysis failing on user-facing code
   - Solution: Don't expose `light.createStrip()` or `pins.X` in student-facing APIs
   - Use `light.onboardStrip()` or configuration-based approaches instead

### Debugging Methodology
11. **Use the "3-Strike Rule" for debugging:**
   - Strike 1: Fix the immediate issue
   - Strike 2: Try one alternative approach
   - Strike 3: **Stop and reassess the entire approach**
   - If the same error appears with different parameters ‚Üí you're treating symptoms, not root cause

12. **When user says "match prod/production behavior":**
   - Look at prod implementation FIRST, not last
   - Copy patterns from working boards before innovating
   - "Matching prod" usually means "use standard blocks/namespaces"

### Error Pattern Recognition
13. **"parts" system errors indicate:**
   - Static analysis at compile-time is failing
   - User-facing code is calling pin instantiation functions (`createStrip`, `createButton`, etc.)
   - Solution: Move hardware-specific logic to internal overrides/hooks
   - Don't try to fix by adjusting pin mappings - that won't help static analysis

14. **WebUSB/Download issues often caused by:**
   - Parts system unable to analyze pin usage at compile time
   - Custom abstractions exposing low-level pin calls
   - Solution: Use framework's built-in patterns (onboardStrip, pin configs, etc.)

## Kinara Holiday Lantern Boards - Requirements (Oct 20, 2025)

### Hardware Constraints (FIXED - Cannot Change)
- **4 holiday lantern boards total** - Kinara PCB v1 + 3 more variants
- **200 Kinara boards already manufactured**
- **Microcontroller:** Adafruit ItsyBitsy M0 Express on all 4 boards
- **NeoPixels:** 
  - 14 LEDs wired to D9 (independent data line)
  - 11 LEDs wired to D7 (separate independent data line)
  - Total: 25 LEDs per board
- **I2C Sensor:** 
  - SDA on pin 22 (ItsyBitsy pin A4/PA06)
  - SCL on pin 23 (ItsyBitsy pin A5/PA07)
  - INT on D2
- **Speaker:** Pin A0 (ItsyBitsy PA02, pin number 5)
- **Button:** Use existing ItsyBitsy onboard button

### Student Experience Requirements
1. **LED Control:**
   - Must be able to light D9 and D7 strips independently
   - Must be able to control each individual pixel on both strips
   - Simulator must show LEDs lighting up correctly
2. **Abstraction Level:**
   - Prefer more abstraction over less
   - Students don't need to know pin numbers if avoidable
   - Simple, clear API is priority
3. **Deployment:**
   - Must work via WebUSB (manual UF2 drag-and-drop doesn't work on macOS)
   - Code must actually run on hardware (not just upload)
4. **Sensors and Sound:**
   - Must be able to program I2C sensor to control LEDs or sound
   - Must be able to play sound on speaker (Pin A0)
5. **Future:**
   - No curriculum exists yet - we can design the API however works best
   - Solution should scale to 3 additional holiday lantern boards

### Current Status (Oct 20, 2025)
- ‚úÖ WebUSB device matching works (board name in pxtarget.json)
- ‚úÖ Simulator shows LEDs correctly
- ‚ùå Hardware LEDs don't light up after WebUSB upload
- ‚ùå Parts system error: "parts failed to read pin(s) from callsite for: light.createStrip"
- **Root Cause:** Investigating - onboard pixel declarations may be triggering parts system

### Debugging Attempts (Oct 20, 2025)

**Attempt: "Bare Board" Configuration**
- **Hypothesis:** 25 NEOPIXEL entries in `board.json` + `PIN_NEOPIXEL`/`NUM_NEOPIXELS` in `config.ts` trigger parts system to reject manual `createStrip()` calls
- **Test:** Remove all onboard pixel declarations to make Kinara look like Vanilla ItsyBitsy (bare board, no onboard pixels)
- **Changes Made:**
  - `board.json`: `leds: []` (removed 25 NEOPIXEL entries)
  - `board.json`: `onboardComponents: []` (removed "pixel")
  - `config.ts`: Removed `PIN_NEOPIXEL` and `NUM_NEOPIXELS` lines
  - `pxt.json`: Removed `light.ts` from files (backed up as `light.ts.backup2`)
- **Expected:** `light.createStrip(pins.D9, 14)` should compile without parts error and work on hardware
- **Student Code:** `let strip = light.createStrip(pins.D9, 14); strip.setAll(0xff0000)`
- **Trade-off:** Simulator won't show 25 LEDs on Kinara SVG (will show breadboard + generic strip)
- **Result:** Testing in progress

## Methodical Debugging Rules

### Before Making Any Changes
1. **Check for running processes** - Always run `pkill -f "pxt serve"` and verify processes are killed before restarting server
2. **Stop and analyze first** - Never touch code without understanding the problem
3. **Read the working reference** - Find how similar boards solve the same problem
4. **Identify root cause** - Distinguish between symptoms and actual problems
5. **Plan the complete solution** - Map out all changes before starting

### Reference-First Approach
- **"Show me the reference"** - Always examine working examples first
- **"How does [working board] actually do this?"** - Understand the pattern
- **"What's the established approach?"** - Don't invent new patterns

### One Change at a Time
- **Make ONE change** - Never multiple changes simultaneously
- **Test it** - Verify the change works
- **Verify it works** - Confirm the fix before proceeding
- **Then make the next change** - Only after success

### Architecture Understanding
Before coding, explain:
- How the system actually works
- What each piece does  
- Why this approach vs alternatives
- How it fits the established patterns

### Debugging Methodology
- **Use the "3-Strike Rule"** - Stop after 2-3 attempts and reassess
- **Isolate the problem** - Test individual components separately
- **Compare with working systems** - Don't guess, verify against known-good examples

## Boards with Onboard NeoPixels

### Critical Configuration Rules
1. **Empty `pinBlocks: []`** = No breadboard in simulator
2. **Populated `pinBlocks`** = Breadboard shown for external connections
3. **`onboardComponents: ["pixels"]`** (plural!) registers onboard NeoPixels
4. **Never use `onboardComponents: ["pixel"]`** (singular) - simulator won't recognize it

### Required board.json Structure
```json
{
  "visual": {
    "useCrocClips": false,
    "pinBlocks": [],  // MUST be empty for no breadboard
    "leds": [
      {"x": 80, "y": 60, "color": "neopixel", "label": "NEOPIXEL_0"},
      {"x": 120, "y": 60, "color": "neopixel", "label": "NEOPIXEL_1"}
      // One entry per LED with SVG coordinates
    ]
  },
  "gpioPinMap": {
    "D7": "D7",  // Physical pins
    "D9": "D9",
    "NEOPIXEL_0": "NEOPIXEL_0",  // Virtual labels for visualization
    "NEOPIXEL_1": "NEOPIXEL_1"
  },
  "onboardComponents": ["pixels"]  // Must be "pixels" (plural)
}
```

### What NOT to Do
- ‚ùå Don't populate `pinBlocks` if you want no breadboard
- ‚ùå Don't use `"pixel"` (singular) in `onboardComponents`
- ‚ùå Don't add `marginWhenBreadboarding` with empty `pinBlocks`
- ‚ùå Don't create custom TypeScript files with `light.createStrip()` at namespace level
  - This breaks WebUSB on localhost due to parts system analysis
  - Students call `light.createStrip()` in their code, not in board configs

### NeoPixel Labels
- `NEOPIXEL_0`, `NEOPIXEL_1` are **virtual labels** for visualization only
- They map to `leds` array entries by matching the `label` field
- Simulator sorts them numerically automatically
- These are NOT physical pins - just SVG coordinates

### Reference
- See `docs/boards/add-a-new-board.md` Step 3.5 for full documentation
- See `libs/kinara-pcb-v1/` for working example (25 LEDs, dual strips)

## WebUSB and Localhost Testing

### ‚úÖ SOLUTION: WebUSB Device Matching (Oct 20, 2025)

**Root Cause:** MakeCode matches USB devices by the board name in `pxtarget.json`, NOT by configuration in individual board files. When a physical board reports "ItsyBitsy M0 Express" over USB but MakeCode looks for "Kinara PCB v1", the device matching fails.

**Solution:** Change the board name in `pxtarget.json` to match what the physical device reports:

```json
"boardDefinitions": [
    {
        "name": "ItsyBitsy M0 Express",  // Must match USB device name
        "url": "libs/kinara-pcb-v1",      // Can point to custom board
        "variant": "samd21"
    }
]
```

**What Didn't Work:**
- ‚ùå `deviceName` field in `board.json`
- ‚ùå `webUSB.deviceMatch` field in `board.json`
- ‚ùå `inherit` field in `board.json`
- ‚ùå `alias` field in `board.json`
- ‚ùå `webUSB.deviceMatch` field in `pxt.json`
- ‚ùå Adding missing dependencies (`storage`, `pixel`)
- ‚ùå Expanding `gpioPinMap` to match ItsyBitsy
- ‚ùå Changing `driveDisplayName` (this is for bootloader drive, not USB device)

**Key Insight:** USB device identification happens at the **hardware level**. The physical board's firmware reports a hardcoded USB product name. MakeCode uses the `name` field in `pxtarget.json` to match incoming USB devices to board configurations.

**Trade-off:** If you want a custom board name in the UI, you'll need to either:
1. Flash custom firmware to the board that reports a different USB product name, or
2. Accept that the board selector will show "ItsyBitsy M0 Express" but load your custom configuration

### Known WebUSB Issues on Localhost
1. **driveDisplayName must match physical bootloader**
   - If board shows "ITSYBITSYBOOT" in bootloader mode, use that in board.json
   - Mismatch causes WebUSB to connect but transfer times out silently
   
2. **WebUSB may not work on localhost even with correct config**
   - Symptoms: Board enters bootloader (LED changes), but transfer fails
   - Falls back to .uf2 file download prompt
   - May work on production makecode.com but fail locally
   - Root cause often unclear - could be parts system, browser permissions, or UF2 generation

3. **Debugging WebUSB failures:**
   - Check if same code works with different board definition (e.g., ItsyBitsy)
   - Enable debug logging: `localStorage.setItem('pxt_log', '1')`
   - Check Network tab in DevTools during download
   - Compare pxt.json dependencies and features between working/broken boards
   - Test manual .uf2 upload to verify compiled code is valid

4. **Kinara WebUSB Investigation Log (Oct 2025)**
   Systematic investigation of why ItsyBitsy board works with WebUSB on localhost but Kinara doesn't:
   
   **Attempted Fixes:**
   - ‚ùå Added "pixel" feature to pxt.json
   - ‚ùå Expanded gpioPinMap from 4 pins to 45+ pins (matching ItsyBitsy)
   - ‚ùå Added spiPins configuration
   - ‚ùå Changed driveDisplayName to match bootloader ("ITSYBITSYBOOT")
   - ‚ùå Updated device.d.ts from getPinCfg to getPin shim style
   - ‚ùå Made Kinara the defaultBoard in pxtarget.json
   - ‚ùå Removed light.ts (dual-strip logic) temporarily
   - ‚úÖ **Fixed i2cPins inconsistency (Oct 19, 2025):**
     - Changed i2cPins from referencing "A4"/"A5" to "SDA"/"SCL"
     - Added SDA and SCL to gpioPinMap (was missing)
     - Result: "parts no pin found" ERROR IS GONE! üéâ
     - But: WebUSB still doesn't transfer (falls back to .uf2 download)
     - Board enters bootloader (LED green‚Üípurple) but no USB transfer occurs
   
   **Current Error:** "parts no pin found for PinInstantiationIdx: 0"
   - Occurs even with simplest code: `light.createStrip(pins.D9, 14)`
   - Board enters bootloader (green‚Üípurple LED) but transfer times out
   - Falls back to .uf2 file download prompt
   - Chrome USB logs show: "Failed to submit transfer: Other error"
   
   **UF2 File Analysis (Oct 19, 2025):**
   - ‚úÖ Both ItsyBitsy and Kinara generate valid UF2 files
   - ItsyBitsy: 356KB (711 blocks), Kinara: 310KB (619 blocks)
   - 46KB difference due to missing dependencies (pixel, storage, screen, jacdac)
   - UF2 structure is valid for both - difference is in included libraries, not corruption
   
   **Manual UF2 Upload Testing (Oct 19, 2025):**
   - ‚ùå Attempted to test kinara.uf2 via manual drag-and-drop to ITSYBITSYBOOT drive
   - ‚ùå ITSYBITSYBOOT drive doesn't mount on macOS even after:
     - Reflashing bootloader with BOSSA (successful verify)
     - Double-clicking reset (pulsing red LED confirms bootloader mode)
     - Uploading Arduino sketch (successful - LED blink confirmed code works)
   - Device appears in USB as disk4 but with "File System: None"
   - Likely macOS-specific issue - bootloader works (WebUSB + Arduino work), just no mass storage
   - Manual testing ruled out - must rely on WebUSB for validation
   - Note: This is probably not a student issue (Windows typically mounts drives better)
   
   **Current Status:**
   - Simulator: ‚úÖ Working (25 LEDs, dual strips D9/D7)
   - ItsyBitsy WebUSB: ‚úÖ Working on localhost
   - Kinara WebUSB: ‚ùå Failing with parts error + USB transfer error
   - Next: Systematic comparison of board configs to find WebUSB blocker

   **WebUSB Device Matching Investigation (Oct 19-20, 2025):**
   - **Root Cause Identified:** MakeCode WebUSB looks for "Kinara PCB v1" device but physical board identifies as "ItsyBitsy M0 Express"
   - **Evidence:** WebUSB connection works, device selector shows "ItsyBitsy M0 Express - Paired", but getDevices() retries 8 times before falling back to UF2
   - **Attempted Fixes (All Failed):**
     - ‚ùå `"deviceName": "ItsyBitsy M0 Express"` in board.json - No effect
     - ‚ùå `"webUSB": {"deviceMatch": "ItsyBitsy M0 Express"}` in board.json - No effect
     - ‚ùå `"inherit": "adafruit-itsybitsy-m0-express"` in board.json - No effect
     - ‚ùå `"alias": "ItsyBitsy M0 Express"` in board.json - No effect
     - ‚ùå `"webUSB": {"deviceMatch": "ItsyBitsy M0 Express"}` in pxt.json - No effect
   - **‚úÖ SOLUTION FOUND (Oct 20, 2025):**
     - Changed `name` field in `pxtarget.json` from "Kinara PCB v1" to "ItsyBitsy M0 Express"
     - Removed original ItsyBitsy board entry to avoid conflicts
     - Result: Board name in UI shows "ItsyBitsy M0 Express" but loads Kinara configuration
     - This is the ONLY change that matters - all board.json/pxt.json fields were cleaned up

### Dual NeoPixel Pin Support (Multiple Physical Strips)

**Challenge:** Simulator only supports one `neopixelPin`, but hardware has multiple pins

**Solution:** Runtime detection with lazy initialization
```typescript
function isSimulator(): boolean {
    return !control.deviceDalVersion() || control.deviceDalVersion() === "sim";
}

let _unified: light.NeoPixelStrip = null;

export function strip9(): light.NeoPixelStrip {
    if (isSimulator()) {
        if (!_unified) _unified = light.createNeoPixelStrip(pins.D9, 25);
        return _unified.range(0, 14);  // Simulator: unified buffer
    } else {
        return light.createNeoPixelStrip(pins.D9, 14);  // Hardware: real pin
    }
}
```

**Critical:** Never create strips at namespace level - always use lazy initialization to avoid parts system issues

### Board Selection and Default Board Issues (Oct 20, 2025)

**Problem:** After changing `pxtarget.json` defaultBoard to point to Kinara, new projects still default to Trinket M0

**Root Cause Investigation:**
- Changed `defaultBoard.name` to "ItsyBitsy M0 Express" and `url` to "libs/kinara-pcb-v1" for WebUSB matching
- But server continues to default new projects to Adafruit Trinket M0
- Tried restarting server multiple times - change not picked up

**Symptoms:**
- New projects create with Trinket M0 board selected
- Even when user selects "Kinara PCB v1" board, project doesn't fully reload config
- Console shows: `typeof light.strip9` = `undefined` (should be "function")
- Console shows: `typeof pins.D9` = `undefined` (should be "object")
- This indicates Kinara board config not actually loaded despite UI showing it selected

**Board Name Confusion:**
- Original ItsyBitsy library (`libs/adafruit-itsybitsy-m0-express`) still in `bundleddirs`
- Created conflict: Two boards with similar names
- When user selects "ItsyBitsy M0 Express" ‚Üí loads original Adafruit board (wrong)
- When user selects "Kinara PCB v1" ‚Üí should load custom config, but doesn't persist in project

**What We Know Works:**
- ‚úÖ WebUSB device matching works with name "ItsyBitsy M0 Express" in pxtarget.json
- ‚úÖ Board config files (board.json, pxt.json) are correct
- ‚úÖ `i2cPins` fixed to use SDA/SCL, added to gpioPinMap
- ‚úÖ `pixel` and `storage` dependencies added to pxt.json
- ‚úÖ Code compiles and uploads via WebUSB successfully
- ‚úÖ Board transitions from bootloader ‚Üí app mode (console logs confirm)

**What Doesn't Work:**
- ‚ùå `defaultBoard` in pxtarget.json not being respected by server (FIXED: needed chooseBoardOnNewProject: true)
- ‚ùå Board selection in UI doesn't fully reload board config in existing projects
- ‚ùå `light.strip9()` undefined even when "Kinara PCB v1" selected
- ‚ùå `pins.D9` undefined even when "Kinara PCB v1" selected
- ‚ùå LEDs don't light up on hardware (FIXED: wrong function name - createNeoPixelStrip vs createStrip)

**Root Cause Found (Oct 20, 2025):**
- ‚úÖ Setting `"chooseBoardOnNewProject": false` in pxtarget.json **disables `defaultBoard`**
- When board selection is disabled, MakeCode uses a hardcoded fallback (Trinket M0)
- The `defaultBoard` setting is ONLY respected when `chooseBoardOnNewProject: true`

**Solution (Oct 20, 2025):**
- ‚úÖ Set `"chooseBoardOnNewProject": true` to enable board selection
- ‚úÖ Removed `libs/adafruit-itsybitsy-m0-express` from `bundleddirs` to avoid conflicts
- ‚úÖ Now users can select from available boards including Kinara
- This is actually better for multi-board support (will have 4 holiday lantern boards)

**Final Working Configuration:**
- `defaultBoard` in pxtarget.json: "ItsyBitsy M0 Express" ‚Üí `libs/kinara-pcb-v1`
- `chooseBoardOnNewProject`: `true`
- Original ItsyBitsy removed from bundleddirs
- WebUSB device matching works via board name "ItsyBitsy M0 Express"

**Hardware LED Bug Fix (Oct 20, 2025):**
- **Problem:** LEDs worked in simulator but not on hardware
- **Root Cause 1:** `light.ts` was calling `light.createNeoPixelStrip()` which doesn't exist
- **Solution 1:** Changed to `light.createStrip()` (the correct function name)
- **Root Cause 2:** Student code calling `light.createStrip(pins.D9, 14)` triggers parts system error
- **Solution 2:** Pre-configured strips via `light.strip9()` and `light.strip7()` functions
- **Files Changed:** `libs/kinara-pcb-v1/light.ts`
- **Student API:** 
  - `light.strip9()` - Returns pre-configured 14-LED strip for D9
  - `light.strip7()` - Returns pre-configured 11-LED strip for D7
  - No need to specify pins or LED counts
- **Test Result:** Final testing in progress

## Incremental Development from kinara-test (Oct 20, 2025)

### ‚úÖ **Step 1: Dual Strip Hardware Test (PASSED)**
**Date:** Oct 20, 2025
**Objective:** Verify both D9 and D7 strips can be controlled independently on hardware

**Test Code:**
```typescript
let strip9 = light.createStrip(pins.D9, 14)
let strip7 = light.createStrip(pins.D7, 11)
strip9.setAll(0xff0000)  // Red
strip7.setAll(0x0000ff)  // Blue
```

**Results:**
- ‚úÖ Hardware: 14 red LEDs on D9, 11 blue LEDs on D7
- ‚úÖ WebUSB: Device detected and code uploaded successfully
- ‚úÖ Code executed correctly on hardware
- ‚ö†Ô∏è Parts system error: `parts no pin found for PinInstantiationIdx: 0`
  - Error appeared once during download
  - **Non-blocking:** Code compiled, uploaded, and ran successfully
  - UF2 generated correctly despite error
  - This is a simulator/analysis warning, not a runtime failure

**Key Findings:**
- `kinara-test` board configuration (Vanilla ItsyBitsy) works perfectly for Kinara hardware
- Both NeoPixel strips (D9 and D7) are independently controllable
- Parts system error is cosmetic and does not prevent functionality
- Students CAN use `light.createStrip(pins.D9, 14)` directly despite the warning

**Next Step:** ~~Test if `light.ts` wrapper functions~~ SKIPPED - simulator doesn't need it, adds unnecessary complexity

### **Step 2: Add `light.ts` Helper Functions - SKIPPED**
**Date:** Oct 20, 2025
**Decision:** Skip this step to keep architecture simple

**Reasons:**
- Simulator doesn't need `light.ts` - it reads `board.json` directly
- Hardware already works with standard API (`light.createStrip()`)
- Parts system error is cosmetic and non-blocking
- Avoid adding unnecessary complexity
- Students will use standard MakeCode API (transferable skills)

### ‚úÖ **Step 3: Replace ItsyBitsy SVG with Kinara SVG (PASSED)**
**Date:** Oct 20, 2025
**Objective:** Show Kinara lantern artwork in simulator instead of generic ItsyBitsy board

**Changes Made:**
- Copied `libs/kinara-pcb-v1/board.svg` ‚Üí `libs/kinara-test/board.svg`
- Restarted server (no full rebuild needed)

**Test Results:**
- ‚úÖ Simulator displays Kinara lantern SVG (not ItsyBitsy)
- ‚úÖ Hardware: Both strips work (14 red LEDs on D9, 11 blue on D7)
- ‚úÖ WebUSB: Device detected and upload successful
- ‚ö†Ô∏è Parts system error persists (same as Step 1 - non-blocking)
- ‚ö†Ô∏è Simulator shows only 1 generic NeoPixel (expected - will fix in Step 4)

**Key Finding:** Parts system error unchanged - confirms SVG swap didn't break anything

**Next Step:** Add 25 LED position entries to `board.json` for proper simulator visualization


## PR Description Template

# Add Kinara Holiday Lantern Board Support

## Overview

This PR adds support for the Kinara Holiday Lantern PCB v1, a custom board based on the Adafruit ItsyBitsy M0 Express, featuring 25 NeoPixel LEDs arranged in a Kwanzaa Kinara layout with motion sensor and sound capabilities.

## Features

### üé® Hardware Support

- **25 NeoPixel LEDs**: 14 LEDs on pin D9 (flames + candles) and 11 LEDs on pin D7 (base)
- **Motion Sensor**: VCNL4040 proximity sensor via I2C (SDA/SCL) with interrupt on D2
- **Sound Output**: Speaker on pin A0
- **WebUSB Support**: Full device matching and upload functionality

### üéØ Custom API

- **`kinara.strip()`**: Unified API that abstracts dual NeoPixel strips into a single virtual strip
- **`kinara.initMotionSensor()`**: Initialize VCNL4040 proximity sensor
- **`kinara.isMotionDetected()`**: Motion detection with debouncing for toggle behavior
- Automatic simulator vs hardware detection for seamless development

### üñ•Ô∏è Simulator

- **Custom SVG**: Kinara lantern artwork instead of generic board outline
- **25 LED Visualization**: All LEDs individually addressable and visible
- **Motion Sensor Testing**: Clickable button (D2) for simulator testing
- **Edge Detection**: Simulator button implements proper edge detection to match hardware behavior

### üìö Documentation

- Comprehensive √•tisa architecture guide
- Updated board creation documentation
- Kinara-specific README with usage examples

## Technical Details

### Board Configuration

- **Base Board**: Adafruit ItsyBitsy M0 Express (SAMD21)
- **LED Layout**: D9 (14 LEDs) + D7 (11 LEDs) = 25 total
- **I2C Pins**: SDA (A4/PA06), SCL (A5/PA07)
- **Motion Sensor**: VCNL4040 @ 0x60
- **Simulator Mode**: Runtime detection handles unified vs dual-strip rendering

### Motion Sensor Implementation

- Debouncing: 500ms (10 steps √ó 50ms) for reliable toggle behavior
- Threshold: 15 units change in proximity reading
- Simulator: Uses `input.buttonD2` with edge detection for consistent behavior

### Build System

- Removed `dist/` directory from version control (auto-generated build artifacts)
- Added `dist/` to `.gitignore` to prevent future tracking

## Files Changed

### New Files

- `libs/kinara-working/` - Complete board configuration
  - `board.json` - Simulator layout and pin mapping
  - `board.svg` - Custom Kinara artwork
  - `config.ts` - Pin definitions
  - `kinara.ts` - Custom API and motion sensor logic
  - `pxt.json` - Board metadata and dependencies
  - `device.d.ts` - Device type definitions
  - `README.md` - Usage documentation

### Documentation

- `docs/about-atisa.md` - Architecture overview
- `docs/boards/add-a-new-board.md` - Updated board creation guide

### Configuration

- `.cursorrules` - Development guidelines and patterns
- `.gitignore` - Added `dist/` exclusion
- `pxtarget.json` - Board definitions

### Removed

- `libs/kinara-pcb-v1/` - Old experimental board (replaced by kinara-working)

## Testing

### Hardware Testing

- ‚úÖ WebUSB upload and device detection
- ‚úÖ Dual NeoPixel strips (D9 and D7) independently controlled
- ‚úÖ Motion sensor toggle behavior
- ‚úÖ Sound output on A0
- ‚úÖ LED colors match Kwanzaa tradition (red, green, black, gold)

### Simulator Testing

- ‚úÖ All 25 LEDs visible and individually controllable
- ‚úÖ Motion sensor button clickable and functional
- ‚úÖ Edge detection prevents double-triggering
- ‚úÖ Custom Kinara SVG renders correctly

## Notes

- This board is part of the √•tisa holiday lantern series (4 boards planned total)
- The `kinara.strip()` API provides a clean abstraction for student curriculum
- Simulator and hardware use the same code - no conditional compilation needed
- Motion sensor works identically in simulator (via button) and hardware (via I2C)

## Related

- Based on existing holiday lantern ornament patterns
- Follows √•tisa board development best practices
- Designed for children's book curriculum integration